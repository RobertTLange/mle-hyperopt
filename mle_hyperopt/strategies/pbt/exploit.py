import pandas as pd
import numpy as np


class Exploit(object):
    def __init__(self, exploit_config: dict):
        """Exploitation Strategies for PBT (Jaderberg et al. 17)."""
        self.exploit_config = exploit_config
        assert self.exploit_config["strategy"] in [
            "truncation",
            "binary_tournament",
        ]

    def truncation_selection(self, worker_id: int, log: dict):
        """
        Rank networks in population by performance. If network is in bottom 20%
        sample another uniformly from top 20% of population, and copy it.
        """
        most_recent_df = log.get_most_recent_data()
        top_df, bottom_df = log.get_truncation_population(
            most_recent_df, self.truncation_percent
        )
        # Check if worker is in top_df - if not sample from top
        bottom_performer = worker_id in bottom_df["worker_id"].tolist()
        if not bottom_performer:
            # Keep data from worker to continue training
            copy_info, hyperparams, ckpt_path = get_no_copy_data(
                most_recent_df, worker_id
            )
        else:
            # Sample worker to copy from top dataframe (20%)
            copy_from_id = top_df["worker_id"].sample(n=1, random_state=1).values[0]
            copy_info, hyperparams, ckpt_path = get_copy_data(
                most_recent_df, copy_from_id, log.eval_metric
            )
        return copy_info, hyperparams, ckpt_path

    def binary_tournament(self, worker_id: int, log: dict):
        """
        Each member of population randomly selects another member and copies
        all its parameters (hyper & weights) if other memberâ€™s score is better.
        """
        df = log.get_most_recent_data()
        # Only use workers that are already recorded in dataframe
        potential_ids = df["worker_id"].unique().tolist()
        copy_from_id = np.random.choice(potential_ids)
        perf1 = df[df["worker_id"] == worker_id][log.eval_metric].values[0]
        perf2 = df[df["worker_id"] == copy_from_id][log.eval_metric].values[0]
        # Check if worker is worse than other randomly sampled member
        bottom_performer = perf1 < perf2 if log.max_objective else perf1 > perf2
        # Keep data from worker to continue training otw. copy better worker
        if not bottom_performer:
            copy_info, hyperparams, ckpt_path = get_no_copy_data(df, worker_id)
        else:
            copy_info, hyperparams, ckpt_path = get_copy_data(
                df, copy_from_id, log.eval_metric
            )
        return copy_info, hyperparams, ckpt_path

    def __call__(self, batch_proposals: list, log: dict):
        copy_infos, hyperparams, ckpts = [], [], []
        for w_id in range(len(batch_proposals)):
            if self.strategy == "truncation":
                explore, hyper, ckpt = self.truncation_selection(
                    w_id, log, batch_proposals
                )
            elif self.strategy == "binary_tournament":
                explore, hyper, ckpt = self.binary_tournament(
                    w_id, log, batch_proposals
                )
            copy_infos.append(explore)
            hyperparams.append(hyper)
            ckpts.append(ckpt)
        return copy_infos, hyperparams, ckpts


def get_copy_data(df: pd.DataFrame, copy_from_id: int, eval_metric: str):
    """Helper to extract data to copy from other worker."""
    hyperparams = df[df["worker_id"] == copy_from_id]["hyperparams"].values[0]
    ckpt_path = df[df["worker_id"] == copy_from_id]["model_ckpt"].values[0]
    pbt_step_id = df[df["worker_id"] == copy_from_id]["pbt_step_id"].values[0]
    num_updates = df[df["worker_id"] == copy_from_id]["num_updates"].values[0]
    performance = df[df["worker_id"] == copy_from_id][eval_metric].values[0]
    copy_info = {}
    copy_info["copy_bool"] = True
    copy_info["copy_from_worker_id"] = copy_from_id
    copy_info["copy_from_pbt_steps"] = pbt_step_id
    copy_info["copy_from_num_updates"] = num_updates
    copy_info["copy_from_ckpt"] = ckpt_path
    copy_info["copy_from_hyperparams"] = hyperparams
    copy_info["copy_from_performance"] = performance
    return copy_info, hyperparams, ckpt_path


def get_no_copy_data(df: pd.DataFrame, worker_id: int):
    """Helper to summarize data from same worker to continue training."""
    copy_info = {}
    copy_info["copy_bool"] = False
    copy_info["copy_from_worker_id"] = None
    copy_info["copy_from_pbt_steps"] = None
    copy_info["copy_from_num_updates"] = None
    copy_info["copy_from_performance"] = None
    # Keep same parameters and continue training last checkpoint
    hyperparams = df[df["worker_id"] == worker_id]["hyperparams"].values[0]
    ckpt_path = df[df["worker_id"] == worker_id]["model_ckpt"].values[0]
    copy_info["copy_from_ckpt"] = ckpt_path
    copy_info["copy_from_hyperparams"] = hyperparams
    return copy_info, hyperparams, ckpt_path
